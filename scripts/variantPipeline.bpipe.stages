// fastqc generates two zipped directory files using a custom naming convention
// input: two *.fastq files
// output: two *_fastqc.zip files
fastqc = {
    doc "Run FASTQC to generate QC metrics for the fastq files"
    output.dir = "01_fastqc"
    output_dir = "01_fastqc"
    produce("${output_dir}/*_fastqc.zip") {
        exec "fastqc -o ${output_dir} --noextract -f fastq $input1"
        exec "fastqc -o ${output_dir} --noextract -f fastq $input2"
    }
}



// pydmx generates a directory of demultiplexed fastqs named using the specified barcode file
//     it requires python2.7
// input: two *.fastq files and a bars.csv file
// intermediate output: 
//        trimmed: two fastq files derived from original fastq pairs trimmed to shortest sequence in the pair
//        multiplexed: two fastqs with control sequences removed and duplication consolidated along with a summary text file
//   final output:
//        demultiplexed: a pair of fastq files for each barcoded sample (defined by specific barcode file)
pydmx = {
    doc "Runs pydmx to reformat the fastq header and generate consensus sequence"
    out_dir = "02-pydmx/demultiplexed"
    output.dir = "02-pydmx/demultiplexed"
    produce("${out_dir}/*.fastq") {
        exec "python2.7 ${PYDMX} -l $input1.fastq -r $input2.fastq -b ${BARS} -o 02-pydmx "
    }
}


// input: 'r1' and 'r2' fastq files
// output: a *.sam file
bowtie2 = {
    doc "Aligns using Bowtie, generating a SAM file.  Note, this file may be very large."
    output.dir = "03_align"
    produce ("03_align/*.sam") {
        exec "bowtie2 --sensitive -x ${REFERENCE} -1 $input1 -2 $input2 -S ./03_align/" + new File(input1).name.split("\\.[12]\\.fastq")[0] + '.sam'
    }
}


picard_sortsam = {
    doc "Sort SAM file so that its in reference order and convert to BAM."
    tmp_dir    = "./tmp"
    output.dir = "03_align"
    transform("bam") {
        exec """
            java -Xmx4g -Djava.io.tmpdir=$tmp_dir -jar ${PICARD_JARS}/SortSam.jar 
            SO=coordinate 
            INPUT=$input.sam 
            OUTPUT=$output 
            VALIDATION_STRINGENCY=LENIENT 
            CREATE_INDEX=true
        """
    }
}


picard_removedups = {
    doc "Remove duplicates"
    tmp_dir    = "./tmp"
    output.dir = "04_removed_duplicates"
    filter("removed") {
        exec """
            java -Xmx1g -Djava.io.tmpdir=$tmp_dir -jar ${PICARD_JARS}/MarkDuplicates.jar 
            INPUT=$input.bam 
            OUTPUT=$output 
            REMOVE_DUPLICATES=true 
            CREATE_INDEX=true 
            METRICS_FILE=${output}-picard.out.metrics 
            VALIDATION_STRINGENCY=LENIENT
        """
    }
}

picard_markdups = { 
    doc "Mark  duplicates"
    tmp_dir    = "./tmp"
    output.dir = "04_marked_duplicates"
    filter("marked") {
        exec """ 
            java -Xmx1g -Djava.io.tmpdir=$tmp_dir -jar ${LIBRARY_LOCATION}/picard-tools-1.115/MarkDuplicates.jar 
            INPUT=$input.bam 
            OUTPUT=$output 
            REMOVE_DUPLICATES=false 
            CREATE_INDEX=true 
            METRICS_FILE=${output}-picard.out.metrics 
            VALIDATION_STRINGENCY=LENIENT
        """ 
    }   
}

samtools_mpileup = {
	doc "mpileup to create the files needed to messure coverage across the samples"
	output.dir = "05_coverage"
	produce("05_coverage/*.pileup"){

	exec "samtools mpileup -d 1000000 $input.bam > ./05_coverage/" + new File(input1).name.split("\\.[12]\\.bam")[0] + '.pileup'

	}

}


trim_pileup = {
	doc " this trims large .pileup file to a smaller file that is more easily transfered and presents coverage intuitively"
	output.dir = "05_coverage"
	transform("05_coverage/*.cov"){
		from("*.pileup"){
			exec "${SCRIPTS}/Trim_to_coverage.py $input.pileup ${input}.cov"
		}	
	}
}




deepsnv = {
	doc "Runs a basic deepSNV script to call variants in each sample saving the outputs as .Rdata files and csv of the summary output"
	output.dir = "06_deepSNV"
		
	//This finds the control bam file.  Currently it looks for a file matching the control name that includes name.(something).bam
	// where something is most likely marked or removed dependeding on how the pipeline ran.
	// I would rather direct it to the directory begining in 04 but I should think about that.  
	//also we currently run the control which is not need.
	//The current directory here is the output directory
	new File('.').eachFileRecurse{
		if(it.name=~/.*$CONTROL.*\..*\.bam$/){
		def control_bam = it.getPath()
		print control_bam

				produce("06_deepSNV/*"){
					exec "Rscript  ${SCRIPTS}/deepSNV.r ${LIBRARY_LOCATION} ${REFERENCE_FA} $input1 $control_bam"
							}
				}		
	}
}

rename = {
	doc "runs basic shell script to rename remove everything after the _ in the sample name"
	exec "${SCRIPTS}/rename1.sh input.fastq"
}
